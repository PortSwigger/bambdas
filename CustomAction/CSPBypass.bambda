id: 87693a5a-3a31-4caa-a225-b5eb87ae686c
name: CSP bypass
function: CUSTOM_ACTION
location: REPEATER
source: |+
  /**
  * Reads the CSP of a response and detects if there is a CSP bypass.
  * Big thanks https://bsky.app/profile/renniepak.nl for CSPBypass.com
  * Note: Makes a HTTP request to
  * https://raw.githubusercontent.com/renniepak/CSPBypass/refs/heads/main/data.tsv
  *
  * @author Gareth Heyes
  */

  if (requestResponse.request().httpService() == null || requestResponse.response() == null) {
      return;
  }

  var noBypassMessage =
      "CSP allows scripts from any domain for " +
      requestResponse.request().httpService().host();

  // If no Content-Security-Policy header, no bypass
  if (!requestResponse.response().hasHeader("Content-Security-Policy")) {
      api().logging().logToOutput(noBypassMessage);
      return;
  }

  //Big thanks https://bsky.app/profile/renniepak.nl
  var dataUrl = "https://raw.githubusercontent.com/renniepak/CSPBypass/refs/heads/main/data.tsv";

  // Combine multiple CSP headers into a single string
  var sb = new StringBuilder();
  for (var header : requestResponse.response().headers()) {
      if (!"Content-Security-Policy".equalsIgnoreCase(header.name())) {
          continue;
      }

      var value = header.value();
      if (value == null || value.isEmpty()) {
          continue;
      }

      if (sb.length() > 0) {
          sb.append("; ");
      }
      sb.append(value.trim());
  }

  // If headers are empty, no bypass
  var csp = sb.toString();
  if (csp.isEmpty()) {
      api().logging().logToOutput(noBypassMessage);
      return;
  }

  // Check if scripts are allowed from any domain
  boolean scriptsAllowedFromAnyDomain;
  {
      if (csp == null || csp.isEmpty()) {
          scriptsAllowedFromAnyDomain = true;
      } else {
          var directives = new HashMap<String, String>();

          for (var part : csp.split(";")) {
              var trimmed = part.trim();
              if (trimmed.isEmpty()) {
                  continue;
              }

              int space = trimmed.indexOf(' ');
              if (space == -1) {
                  continue;
              }

              var name = trimmed.substring(0, space).toLowerCase(Locale.ROOT);
              var value = trimmed.substring(space + 1).trim();
              directives.put(name, value);
          }

          var sources = directives.get("script-src");
          if (sources == null) {
              sources = directives.get("default-src");
          }

          if (sources == null || sources.isEmpty()) {
              scriptsAllowedFromAnyDomain = true;
          } else {
              var tokens = sources.split("\\s+");

              boolean hasNone = false;
              for (var t : tokens) {
                  if ("'none'".equals(t)) {
                      hasNone = true;
                      break;
                  }
              }

              if (hasNone) {
                  scriptsAllowedFromAnyDomain = false;
              } else {
                  boolean hasWildcard = false;
                  boolean hasSchemeWildcard = false;

                  for (var t : tokens) {
                      if ("*".equals(t)) {
                          hasWildcard = true;
                      } else if (t.endsWith(":")) {
                          hasSchemeWildcard = true;
                      }
                  }

                  scriptsAllowedFromAnyDomain = hasWildcard || hasSchemeWildcard;
              }
          }
      }
  }

  // If scripts allowed from any domain, no bypass
  if (scriptsAllowedFromAnyDomain) {
      api().logging().logToOutput(noBypassMessage);
      return;
  }

  // Fetch all bypass vectors
  var vectors = new ArrayList<String>();
  {
      try {
          var http = api().http();
          var tsvRequest = HttpRequest.httpRequestFromUrl(dataUrl);
          var tsvResponse = http.sendRequest(tsvRequest, HttpMode.HTTP_1);

          if (tsvResponse.hasResponse()) {
              var body = tsvResponse.response().bodyToString();
              if (body != null && !body.isEmpty()) {
                  var lines = body.split("\\R");

                  for (var line : lines) {
                      var trimmed = line.trim();
                      if (trimmed.isEmpty() || trimmed.startsWith("#")) {
                          continue;
                      }

                      var parts = trimmed.split("\\t", 2);
                      if (parts.length < 2) {
                          continue;
                      }

                      var host = parts[0].trim();
                      var vector = parts[1].trim();
                      if (host.isEmpty() || vector.isEmpty()) {
                          continue;
                      }

                      String quoted = Pattern.quote(host);
                      String pattern = "(^|[\\s;])(?:\\*\\.)?" + quoted + "(?=[\\s;]|$)";
                      if (Pattern.compile(pattern).matcher(csp).find()) {
                          vectors.add(vector);
                      }
                  }
              }
          }
      } catch (Exception e) {
          api().logging().logToError("Failed to fetch or parse CSP bypass data: " + e.getMessage());
      }
  }

  if (!vectors.isEmpty()) {
      api().logging().logToOutput("These vectors use data from CSPbypass.com. Use at your own risk.\n");
      api().logging().logToOutput("Found CSP bypass vectors:\n");
      for (var v : vectors) {
          api().logging().logToOutput(v.replaceAll("<script src", "<script/src") + "\n");
      }
  } else {
      api().logging().logToOutput("No CSP bypass found.");
  }