<!--
*** AUTO-GENERATED FILE ***
This file is auto-generated by BambdaChecker.
Please do not manually edit this file, or include any changes to this file in pull requests.
-->
# Proxy HTTP
Documentation: [Filtering the HTTP history with Bambdas](https://portswigger.net/burp/documentation/desktop/tools/proxy/http-history/bambdas)
## [FilterHighlightAnnotateOWASP.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterHighlightAnnotateOWASP.bambda)
### Filters Proxy HTTP history for requests with vulnerable parameters based on the OWASP Top 25 using the parameter arrays written by Tur24Tur / BugBountyzip (https://github.com/BugBountyzip).
#### Author: Shain Lakin (https://github.com/flamebarke/SkittlesBambda)
```java
// Define vulnerable parameter group record
record VulnParamGroup(String title, HighlightColor color, String... parameterNames) {}

// Vulnerable Parameter Groups
VulnParamGroup ssrf = new VulnParamGroup("SSRF", HighlightColor.GREEN, "dest", "redirect", "uri", "path", "continue", "url", "window", "next", "data", "reference", "site", "html", "val", "validate", "domain", "callback", "return", "page", "feed", "host", "port", "to", "out", "view", "dir");
VulnParamGroup sql = new VulnParamGroup("SQL", HighlightColor.BLUE, "id", "page", "report", "dir", "search", "category", "file", "class", "url", "news", "item", "menu", "lang", "name", "ref", "title", "view", "topic", "thread", "type", "date", "form", "main", "nav", "region");
VulnParamGroup xss = new VulnParamGroup("XSS", HighlightColor.ORANGE, "q", "s", "search", "id", "lang", "keyword", "query", "page", "keywords", "year", "view", "email", "type", "name", "p", "month", "image", "list_type", "url", "terms", "categoryid", "key", "l", "begindate", "enddate");
VulnParamGroup lfi = new VulnParamGroup("LFI", HighlightColor.YELLOW, "cat", "dir", "action", "board", "date", "detail", "file", "download", "path", "folder", "prefix", "include", "page", "inc", "locate", "show", "doc", "site", "type", "view", "content", "document", "layout", "mod", "conf");
VulnParamGroup or = new VulnParamGroup("OR", HighlightColor.PINK, "next", "url", "target", "rurl", "dest", "destination", "redir", "redirect_uri", "redirect_url", "redirect", "out", "view", "to", "image_url", "go", "return", "returnTo", "return_to", "checkout_url", "continue", "return_path");
VulnParamGroup rce = new VulnParamGroup("RCE", HighlightColor.RED, "cmd", "exec", "command", "execute", "ping", "query", "jump", "code", "reg", "do", "func", "arg", "option", "load", "process", "step", "read", "feature", "exe", "module", "payload", "run", "print");

// Toggle for highlighting
boolean highlightEnabled = true;

// Set multi vulnerable parameter group colour
HighlightColor multipleVulnColor = HighlightColor.MAGENTA;
VulnParamGroup[] groups = {ssrf, sql, xss, lfi, or, rce};
Set<String> foundParams = new HashSet<>();
Map<HighlightColor, Integer> colorCounts = new HashMap<>();
String combinedNotes = "";

// Get the request object
var request = requestResponse.request();

// Main loop to check for matches
for (VulnParamGroup group : groups) {
    for (String paramName : group.parameterNames()) {
        if (request.hasParameter(paramName, HttpParameterType.URL) ||
            request.hasParameter(paramName, HttpParameterType.BODY)) {
            if (highlightEnabled) {
                foundParams.add(group.title() + ": " + paramName);
                colorCounts.put(group.color(), colorCounts.getOrDefault(group.color(), 0) + 1);
            }
            // Return if only one vulnerability class applies
            if (!highlightEnabled) {
                requestResponse.annotations().setHighlightColor(group.color());
                return true;
            }
        }
    }
}

// If more than one vulnerability class applies set the multi vulnerable parameter colour
if (!foundParams.isEmpty()) {
    HighlightColor highlightColor = multipleVulnColor;
    if (colorCounts.size() == 1) {
        highlightColor = colorCounts.keySet().iterator().next();
    }

    requestResponse.annotations().setHighlightColor(highlightColor);
    combinedNotes = String.join(", ", foundParams);
    requestResponse.annotations().setNotes(combinedNotes);
    return true;
}

return false;

```
## [FilterOnCookieValue.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterOnCookieValue.bambda)
### Filters Proxy HTTP history for requests with a specific Cookie value.
#### Author: LostCoder
```java
if (requestResponse.request().hasParameter("foo", HttpParameterType.COOKIE)) {
	var cookieValue = requestResponse
		.request()
		.parameter("foo", HttpParameterType.COOKIE)
		.value();

	return cookieValue.contains("1337");
}

return false;

```
## [FilterOnSpecificHighlightColor.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterOnSpecificHighlightColor.bambda)
### Filters requests/responses for specific highlight colors
#### Author: Nick Coblentz (https://github.com/ncoblentz)
```java
return requestResponse.annotations().highlightColor().equals(HighlightColor.CYAN);

```
## [FilterOutOptionsRequests.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FilterOutOptionsRequests.bambda)
### Filter out OPTIONS requests.
#### Author: Trikster
```java
return !requestResponse.request().method().equals("OPTIONS");

```
## [FindJSONresponsesWithIncorrectContentType.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/FindJSONresponsesWithIncorrectContentType.bambda)
### Finds JSON responses with wrong Content-Type  The content is probably json but the content type is not application/json
#### Author: albinowax
```java
var contentType = requestResponse.hasResponse() ? requestResponse.response().headerValue("Content-Type") : null;

if (contentType != null && !contentType.contains("application/json")) {
 String body = requestResponse.response().bodyToString().trim();

 return body.startsWith( "{" ) || body.startsWith( "[" );
}

return false;

```
## [HighlightDeprecatedHTTPMethods.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/HighlightDeprecatedHTTPMethods.bambda)
### Filters and highlights requests using less common or deprecated HTTP methods like TRACE or CONNECT.
#### Author: Tur24Tur / BugBountyzip (https://github.com/BugBountyzip)
```java
boolean manualColorHighlightEnabled = true;

// Define the set of deprecated or less common HTTP methods
Set<String> deprecatedMethods = Set.of("TRACE", "CONNECT");

String requestMethod = requestResponse.request().method();

// Check if the request method is in the set of deprecated methods
if (deprecatedMethods.contains(requestMethod)) {
    if (manualColorHighlightEnabled) {
        // Set the highlight color to RED
        requestResponse.annotations().setHighlightColor(HighlightColor.RED);

        // Optionally, add a note to the request/response
        requestResponse.annotations().setNotes("Deprecated method used: " + requestMethod);
    }
    return true;
}

return false;

```
## [HighlightUnencryptedHTTP.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/HighlightUnencryptedHTTP.bambda)
### Bambda Script to Highlight Unencrypted HTTP Traffic Filters Proxy HTTP history for unencrypted (non-HTTPS) requests.
#### Author: Tur24Tur / BugBountyzip (https://github.com/BugBountyzip)
```java
// Get the request object from the requestResponse
var request = requestResponse.request();

// Extract the URL from the request
var requestUrl = request.url();

// Check if the request URL starts with "http://"
if (requestUrl.startsWith("http://")) {
    // URL is unencrypted, return true to highlight this request
    return true;
}

// URL is encrypted or does not match the criteria, return false
return false;

```
## [OWASPTop25VulnerableParameters.bambda](https://github.com/PortSwigger/bambdas/blob/main/Proxy/HTTP/OWASPTop25VulnerableParameters.bambda)
### Filters Proxy HTTP history for requests with vulnerable parameters based on the OWASP Top 25
#### Author: Tur24Tur / BugBountyzip (https://github.com/BugBountyzip)
```java
// Define the vulnerable parameters as a Set based on OWASP Top 25
Set<String> parameterNames = Set.of(
    // SSRF parameters
    "dest", "redirect", "uri", "continue", "url", "window", "data",
    "reference", "site", "html", "val", "validate", "domain", "callback", "return",
    "page", "feed", "host", "port", "to", "out", "dir",
    // SQL injection parameters
    "id", "select", "report", "search", "category", "file", "class", "news",
    "item", "menu", "ref", "title", "topic", "thread",
    "form", "main", "nav", "region",
    // XSS parameters
    "q", "s", "lang", "keyword", "keywords", "year", "email",
    "type", "name", "p", "month", "image", "list_type", "terms", "categoryid", "key",
    "l", "begindate", "enddate",
    // LFI parameters
    "cat", "action", "board", "date", "detail", "download", "path", "folder",
    "prefix", "include", "inc", "locate", "show", "doc", "view",
    "content", "document", "layout", "mod", "conf",
    // Open Redirect parameters
    "next", "target", "rurl", "destination", "redir", "redirect_uri",
    "redirect_url", "image_url", "go",
    "returnTo", "return_to", "checkout_url", "return_path",
    // RCE parameters
    "cmd", "exec", "command", "execute", "ping", "query", "jump", "code", "reg", "do",
    "func", "arg", "option", "load", "process", "step", "read", "feature", "exe",
    "module", "payload", "run", "print"
);

// Get the request object
var request = requestResponse.request();

// Iterate through each parameter name and check if it exists in the request URL or body
for (String param : parameterNames) {
    if (request.hasParameter(param, HttpParameterType.URL) ||
        request.hasParameter(param, HttpParameterType.BODY)) {
        return true;
    }
}

return false;

```
